// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

/// @title Simple Voting System (Remix-ready) - modified
/// @notice Adds helper views and an owner-only voter reset for testing/debugging
contract Voting {
    address public owner;
    string public electionName;

    struct Voter {
        uint256 weight;     // weight is accumulated by delegation
        bool voted;         // if true, that person already voted
        address delegate;   // person delegated to
        uint256 vote;       // index of the voted proposal
    }

    struct Proposal {
        string name;        // short name (up to front-end)
        uint256 voteCount;  // number of accumulated votes
    }

    Proposal[] public proposals;
    mapping(address => Voter) public voters;

    // Voting time control
    uint256 public votingStartsAt; // timestamp
    uint256 public votingEndsAt;   // timestamp
    bool public votingActive;

    // Events
    event ProposalAdded(uint256 indexed proposalId, string name);
    event RightGranted(address indexed voter);
    event Voted(address indexed voter, uint256 indexed proposal);
    event Delegated(address indexed from, address indexed to);
    event VotingStarted(uint256 startsAt, uint256 endsAt);
    event VotingEnded(uint256 endsAt);

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }

    modifier onlyWhileActive() {
        require(votingActive, "Voting not active");
        require(block.timestamp >= votingStartsAt, "Voting not yet started");
        require(block.timestamp <= votingEndsAt, "Voting ended");
        _;
    }

    constructor(string memory _electionName, string[] memory _proposalNames) {
        owner = msg.sender;
        electionName = _electionName;

        // Add proposals (created by owner at deploy)
        for (uint256 i = 0; i < _proposalNames.length; i++) {
            proposals.push(Proposal({name: _proposalNames[i], voteCount: 0}));
            emit ProposalAdded(i, _proposalNames[i]);
        }

        // Optionally give owner the right to vote
        voters[owner].weight = 1;
    }

    /// @notice Owner grants voting right to an address
    function giveRightToVote(address voter) external onlyOwner {
        require(!voters[voter].voted, "Already voted");
        require(voters[voter].weight == 0, "Already has right");
        voters[voter].weight = 1;
        emit RightGranted(voter);
    }

    /// @notice Owner can add more proposals before voting starts
    function addProposal(string calldata name) external onlyOwner {
        require(!votingActive, "Can't add after start");
        proposals.push(Proposal({name: name, voteCount: 0}));
        emit ProposalAdded(proposals.length - 1, name);
    }

    /// @notice Start voting for `durationSeconds` seconds
    function startVoting(uint256 durationSeconds) external onlyOwner {
        require(!votingActive, "Voting already active");
        require(durationSeconds > 0, "Duration>0");
        votingActive = true;
        votingStartsAt = block.timestamp;
        votingEndsAt = block.timestamp + durationSeconds;
        emit VotingStarted(votingStartsAt, votingEndsAt);
    }

    /// @notice End voting immediately (owner override). Emits VotingEnded.
    function endVotingNow() external onlyOwner {
        require(votingActive, "Voting not active");
        votingActive = false;
        votingEndsAt = block.timestamp;
        emit VotingEnded(votingEndsAt);
    }

    /// @notice Delegate your vote to another voter
    function delegate(address to) external onlyWhileActive {
        Voter storage sender = voters[msg.sender];
        require(sender.weight > 0, "No right to vote");
        require(!sender.voted, "Already voted");
        require(to != msg.sender, "Self-delegation not allowed");

        // Follow the chain of delegation to prevent loops
        address curr = to;
        while (voters[curr].delegate != address(0)) {
            curr = voters[curr].delegate;
            // If we find a loop, abort
            require(curr != msg.sender, "Delegation loop detected");
        }

        sender.voted = true;
        sender.delegate = to;
        emit Delegated(msg.sender, to);

        Voter storage delegate_ = voters[to];
        if (delegate_.voted) {
            // If the delegate already voted, add weight to the chosen proposal
            proposals[delegate_.vote].voteCount += sender.weight;
        } else {
            // If the delegate did not vote yet, add weight to delegate
            delegate_.weight += sender.weight;
        }
    }

    /// @notice Cast your vote for proposal index `proposal`
    function vote(uint256 proposal) external onlyWhileActive {
        Voter storage sender = voters[msg.sender];
        require(sender.weight > 0, "No right to vote");
        require(!sender.voted, "Already voted");
        require(proposal < proposals.length, "Invalid proposal");

        sender.voted = true;
        sender.vote = proposal;

        // If voter has weight >1 (via delegation), add that many votes
        proposals[proposal].voteCount += sender.weight;

        emit Voted(msg.sender, proposal);
    }

    /// @notice Read proposal count
    function proposalCount() external view returns (uint256) {
        return proposals.length;
    }

    /// @notice Compute winning proposal index (view)
    function winningProposal() public view returns (uint256 winningProposalIndex) {
        uint256 highest = 0;
        uint256 winningIndex = 0;
        for (uint256 i = 0; i < proposals.length; i++) {
            if (proposals[i].voteCount > highest) {
                highest = proposals[i].voteCount;
                winningIndex = i;
            }
        }
        return winningIndex;
    }

    /// @notice Return the name of the winning proposal
    function winnerName() external view returns (string memory) {
        uint256 w = winningProposal();
        return proposals[w].name;
    }

    /// @notice Utility: check if voting has ended by time
    function isVotingClosed() external view returns (bool) {
        if (!votingActive) return true;
        return block.timestamp > votingEndsAt;
    }

    /// @notice Owner can reset the election (careful: clears proposals & voters) - only when voting inactive
    function resetElection(string calldata newName, string[] calldata newProposals) external onlyOwner {
        require(!votingActive, "Can't reset during active voting");

        // Clear proposals
        delete proposals;

        // Note: mapping can't be fully cleared â€” this is a simple reset approach.
        // For production, consider a better pattern (new contract per election or track epoch).
        // Here we rely on fresh deployment for full clean state if needed.

        electionName = newName;
        for (uint256 i = 0; i < newProposals.length; i++) {
            proposals.push(Proposal({name: newProposals[i], voteCount: 0}));
            emit ProposalAdded(i, newProposals[i]);
        }

        // Owner keeps voting right
        voters[owner].weight = 1;
    }

    // ------------------ NEW HELPERS (added) ------------------

    /// @notice Return simple voter info for debugging / frontend
    function getVoter(address a) external view returns (uint256 weight, bool voted, address delegatedTo, uint256 votedProposal) {
        Voter storage v = voters[a];
        return (v.weight, v.voted, v.delegate, v.vote);
    }

    /**
     * @notice Owner-only helper to clear a single voter's record and undo their effect on tallies.
     * @dev This is intended for testing or admin correction only. Use with caution on a live election.
     *      The function attempts to reverse any vote contribution the address previously made:
     *      - If the voter voted directly (delegate == address(0) and voted == true), it subtracts their weight
     *        from the voted proposal's voteCount.
     *      - If the voter delegated to someone who already voted, it subtracts from that proposal.
     *      - If the voter delegated to someone who hasn't voted, it subtracts from the delegate's weight.
     *      After adjustments it deletes the voter's struct (resets to zero/default).
     */
    function resetVoter(address a) external onlyOwner {
        Voter storage v = voters[a];
        if (v.weight == 0 && !v.voted && v.delegate == address(0)) {
            // nothing to do
            delete voters[a];
            return;
        }

        // If the voter had voted directly (no delegate), remove their contribution
        if (v.voted && v.delegate == address(0)) {
            // safe underflow (Solidity 0.8 checks)
            proposals[v.vote].voteCount -= v.weight;
        } else if (v.voted && v.delegate != address(0)) {
            // They delegated and were marked as voted (i.e., delegation recorded)
            address d = v.delegate;
            // If delegate already voted, remove from that proposal
            if (voters[d].voted) {
                proposals[voters[d].vote].voteCount -= v.weight;
            } else {
                // delegate not voted yet: their weight earlier increased by v.weight, so reduce it
                voters[d].weight -= v.weight;
            }
        } else if (!v.voted && v.delegate != address(0)) {
            // They delegated but their 'voted' flag is false (shouldn't happen normally since delegate() sets voted=true)
            address d2 = v.delegate;
            if (voters[d2].voted) {
                proposals[voters[d2].vote].voteCount -= v.weight;
            } else {
                // remove granted weight from delegate
                voters[d2].weight -= v.weight;
            }
        }

        // Finally clear the voter record
        delete voters[a];
    }

    // ------------------ END NEW HELPERS ------------------
}
